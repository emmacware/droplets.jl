function run__(i::Int, droplets::droplet_attributes{FT}, coagsettings::coag_settings{FT}, 
    runsettings::run_settings{FT}, data) where FT<:AbstractFloat 

    bin,timing,deficit = coag_runtime_deficit(i,droplets,coagsettings,runsettings)
    error = error_measure(bin[:,4],Gsolution[:,4])

    key = (runsettings.init_method,Int(log2(coagsettings.Ns)), coagsettings.Δt, i)
    data[key] = (bin, timing, error,deficit)
    println("Ns = ",coagsettings.Ns,", dt = ",coagsettings.Δt)
end

function init_droplets(exp,initm::PyObject)
    attributes = Dict()
    attributes["volume"], attributes["multiplicity"] = initm(spectrum=initial_spectrum).sample(2^exp)
    attributes["multiplicity"] = Int.(round.(attributes["multiplicity"]))
    attributes["radius"] = volume_to_radius.(attributes["volume"])
    droplets = droplet_attributes(attributes["multiplicity"], attributes["radius"], attributes["volume"])
    return droplets
end

function all_runs(scheme,init_py::NamedTuple,runs::Vector,
    dts::Vector{FT},seeds::Int,data) where FT<:AbstractFloat 

    nsdtypes = length(runs)

    for exp in 1:nsdtypes
        for j in eachindex(init_py)
            starting_drops = init_droplets(runs[exp],init_py[j])
    
            for dt in dts
                    coagsettings = coag_settings{FT}(Ns=2^runs[exp],Δt=dt)
                    runsettings=run_settings{FT}(coag_threading=Serial(),scheme=scheme,init_method ="$(j)")    
                for i in 1:seeds                    
                    droplets = deepcopy(starting_drops)
                    run__(i, droplets, coagsettings, runsettings, data)
                end
            end
        end
    end
end


function fill_heatmap_data!(scheme::none,data,results,runs::Vector,dts::Vector{FT},seeds,f_idx) where FT<:AbstractFloat 
    num_dts = length(dts)
    num_runs = length(runs)
    for i in 1:num_dts
        for j in 1:num_runs
            dt = dts[i]
            run = runs[j]
            results[f_idx]["MeanTime"][i][j] = (mean([data[(f_idx, run, dt, s)][2] for s in 2:seeds]))
            avgbins = mean([data[(f_idx, run, dt, s)][1] for s in 2:seeds])
            results[f_idx]["Error"][i][j] = error_measure(avgbins[:,4],Gsolution[:,4])
            results[f_idx]["Deficit"][i][j] = (mean([data[(f_idx, run, dt, s)][4] for s in 2:seeds]))/3600
        end
    end
end

function fill_heatmap_data!(scheme::Adaptive,data,results,runs::Vector,dts::Vector{FT},seeds,f_idx) where FT<:AbstractFloat 
    num_dts = length(dts)
    num_runs = length(runs)
    for i in 1:num_dts
        for j in 1:num_runs
            dt = dts[i]
            run = runs[j]
            results[f_idx]["MeanTime"][i][j] = (mean([data[(f_idx, run, dt, s)][2] for s in 2:seeds]))
            avgbins = mean([data[(f_idx, run, dt, s)][1] for s in 2:seeds])
            results[f_idx]["Error"][i][j] = error_measure(avgbins[:,4],Gsolution[:,4])
        end
    end
end


function heatmap_data!(scheme::none,data,results,init_names,runs,dts,seeds)
    num_dts = length(dts)
    num_runs = length(runs)
    for f_idx in init_names
        results[f_idx] = Dict()
        results[f_idx]["Error"] = [[0.0 for _ in 1:num_runs] for _ in 1:num_dts]
        results[f_idx]["MeanTime"] = [[0.0 for _ in 1:num_runs] for _ in 1:num_dts]
        results[f_idx]["Deficit"] = [[0.0 for _ in 1:num_runs] for _ in 1:num_dts]

        fill_heatmap_data!(scheme,data,results,runs,dts,seeds,f_idx)
    end
end

function heatmap_data!(scheme::Adaptive,data,results,init_names,runs,dts,seeds)
    num_dts = length(dts)
    num_runs = length(runs)
    for f_idx in init_names
        results[f_idx] = Dict()
        results[f_idx]["Error"] = [[0.0 for _ in 1:num_runs] for _ in 1:num_dts]
        results[f_idx]["MeanTime"] = [[0.0 for _ in 1:num_runs] for _ in 1:num_dts]

        fill_heatmap_data!(scheme,data,results,runs,dts,seeds,f_idx)
    end
end


function create_heatmap(results,normerror,normtime,runs,dts,init_names;Deficit = true)
    heatmaps = []
    num_init_m = length(init_names)

    # Put global color limits
    error_min = .08
    error_max = 2.5
    time_min = 1
    time_max = 5e2
    if Deficit
        deficit_min = 1
        deficit_max = 1e9
    end
    for f_idx in 1:num_init_m
        heatmap_error = each_heatmap(runs,dts,results[init_names[f_idx]]["Error"],"Error",error_min,error_max,norm=normerror)
        heatmap_time = each_heatmap(runs,dts,results[init_names[f_idx]]["MeanTime"],"MeanTime",time_min,time_max,norm=normtime)
        
        push!(heatmaps, heatmap_error)
        push!(heatmaps, heatmap_time)
        if Deficit
            heatmap_deficit = each_heatmap(runs,dts,results[init_names[f_idx]]["Deficit"],"Deficit",deficit_min,deficit_max)
            push!(heatmaps, heatmap_deficit)
        end
    end
    return heatmaps
end

function each_heatmap(runs,dts,data,name,min,max;norm = 1,cgrad = :viridis)
    num_dts = length(dts)
    dt_values = 1:num_dts
    dtslabel = string.(dts')

    heatmap(runs, dt_values, hcat(data...)'./norm, xticks=runs, yticks=(1:num_dts, string.(dtslabel)),
            xlabel="log2(Ns)", ylabel="dt", colorbar_title=name, title=name,
            c=cgrad,colorbar_scale=:log10,
            colorbar_titlefont=font(10, "Arial", 0, 0),colorbar_titlepadding=.1,clim=(min, max))
    contour!(runs, dt_values, hcat(data...)'./norm, levels=20, color=:blues, clim=(min, max), zscale=:log10)
end



function coag_runtime_deficit(randseed::Int,droplets::droplet_attributes,
    coag_settings::coag_settings{FT},run_settings::run_settings{FT}) where FT<:AbstractFloat
    
    Random.seed!(randseed)
    println("Running simulation...")

    coal_func_time::FT = 0.0
    bins::Matrix{FT} = zeros(FT, run_settings.num_bins, length(run_settings.output_steps))
    threading,scheme = run_settings.coag_threading, run_settings.scheme
    coag_data = coagulation_run{FT}(coag_settings.Ns)
    simtime::FT = @CPUelapsed begin
        for i  in  1:length(run_settings.output_steps)
            # if i,seconds in enumerate(run_settings.output_steps)
            
            if i !=1
                timestepper = (run_settings.output_steps[i]-run_settings.output_steps[i-1])/coag_settings.Δt
                ctime::FT = @CPUelapsed begin
                    for _ in 1:timestepper
                        coalescence_timestep!(threading,scheme,droplets,coag_data,coag_settings)
                    end
                end
                coal_func_time += ctime
            end
            bins[:,i] = binning_func(droplets,run_settings.output_steps[i],run_settings,coag_settings)
            # println("Time: ", run_settings.output_steps[i], " seconds")
        end
    end
    println("simtime =", simtime)
    println("coal_func_time =", coal_func_time)
    deficit = coag_data.deficit[]
    return bins, coal_func_time,deficit
end


function error_versus_time(results,runs,dts,shape)
    err = hcat(results["Error"]...)'
    times = hcat(results["MeanTime"]...)'
    pl1 = plot!()
    for i in eachindex(runs)
        plot!(times[:,i],err[:,i],label=runs[i],markershape=shape,markersize=dts./2)
    end
    return pl1
end

function error_versusdt(results,runs,dts,shape)
    err = hcat(results...)
    pl1 = plot!()
    colors = [:red, :blue, :green, :orange, :purple, :brown, :pink, :gray, :cyan, :magenta]
    for i in eachindex(runs)
        plot!(dts,err[i,:],label="Ns = 2^$(runs[i])",
        markershape=shape,
        linewidth=2,#(runs[i]-12),
        color=colors[i],#,
        yscale=:log)#,markersize=runs./2)
    end
    plot!(legend=:bottomright)
    ylims!(2e-6,8e-4)
    xlabel!("dt")
    ylabel!("RMSE Error (kg/m^3/unit lnr)")
    return pl1
end

function error_versus_time_vanishingpoint(results,runs,dts,shape;line=:dash)
    err = hcat(results["Error"]...)
    times = hcat(results["MeanTime"]...)
    pl1 =plot!()
    colors = [:red, :blue, :green, :orange, :purple, :brown, :pink, :gray, :cyan, :magenta]
    for i in eachindex(dts)
        plot!(times[:,i],err[:,i],scale=:log,ls=line,
        label="dt = $(dts[i])",
        markershape=shape,markersize=(runs.-12),
        markerstrokecolor=false,
        color=colors[i % length(colors) + 1])
    end
    xlabel!("Runtime")
    plot!(legend=:bottomright)
    ylabel!("Error")
    return pl1
end

# plot(title="No Adaptivivity")
# p1 = error_versus_time_vanishingpoint(Droplets_Regular["ConstantMultiplicity"]["Error"],log2_Ns,dts,:circle, line=:dash)
# plot(title="Adaptivivity")
# p2 = error_versus_time_vanishingpoint(Droplets_Adaptive["ConstantMultiplicity"]["Error"],log2_Ns,dts,:square, line=:solid)
# plot(p1,p2,layout=(2,1),legend=:topright)

plot(title="Droplets No Adaptivivity")
d1 = error_versusdt(Droplets_Regular["ConstantMultiplicity"]["Error"],log2_Ns,dts,:circle)
plot(title="Droplets Adaptivivity")
d2 = error_versusdt(Droplets_Adaptive["ConstantMultiplicity"]["Error"],log2_Ns,dts,:square)
plot(d1,d2,layout=(1,2),size=(900,400), legend=:topleft)

plot(title = "PySDM No Adaptivivity")
p1 = error_versusdt(PySDM_Data["regular"]["ConstantMultiplicity"]["Error"],log2_Ns,dts,:circle)
plot(title = "PySDM Adaptivivity")
p2 = error_versusdt(PySDM_Data["adaptive"]["ConstantMultiplicity"]["Error"],log2_Ns,dts,:square)
plot(p1,p2,layout=(1,2),legend=:topright)

plot(title="PyPartMC Error")
pp1 = error_versusdt(pyparterror["PyPartMC_err"],log2_Ns,dts,:circle)


fplot = Array{Plots.Plot{Plots.GRBackend}}(undef, length(init_names))
for i in 1:3
    plot()
    f = init_names[i]
    plot(title="Droplets No Adaptivivity")
    d1 = error_versusdt(Droplets_Regular[f]["Error"],log2_Ns,dts,:circle)
    plot(title="Droplets Adaptivivity")
    d2 = error_versusdt(Droplets_Adaptive[f]["Error"],log2_Ns,dts,:square)
    plot(d1,d2,layout=(1,2),size=(900,400))

    plot(title = "PySDM No Adaptivivity")
    p1 = error_versusdt(PySDM_Data["regular"][f]["Error"]/1e6,log2_Ns,dts,:circle)
    plot(title = "PySDM Adaptivivity")
    p2 = error_versusdt(PySDM_Data["adaptive"][f]["Error"]/1e3,log2_Ns,dts,:square)
    plot(p1,p2,layout=(1,2),size=(900,400))

    plot(title="PyPartMC Error")
    pp1 = error_versusdt(pyparterror["PyPartMC_err"],log2_Ns,dts,:circle)

    emptyplot = plot()

    fplot[i] = plot(d1,p1,pp1,d2,p2,layout=(2,3),size=(1200,800),suptitle=f)
end

# plot(fplot...,layout=(1,3),size=(1800, 600))
 